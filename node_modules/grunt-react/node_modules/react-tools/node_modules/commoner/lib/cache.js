var assert = require("assert");
var Q = require("q");
var fs = require("fs");
var path = require("path");
var util = require("./util");
var EventEmitter = require("events").EventEmitter;
var hasOwn = Object.prototype.hasOwnProperty;

/**
 * DiskCache persists processed text to disk so that the work of
 * re-processing the input text can be avoided in the future.  It doubles
 * as an in-process cache so that the underlying file only needs to be
 * accessed once within the same process.
 *
 * Commoner uses the DiskCache to store fully processed module files in
 * the .module-cache/ directory.  When an appropriate module file already
 * exists in the cache directory, a hard link can be quickly created
 * between the cached file and the file in the build output directory.
 */
function DiskCache(cacheDirP) {
    var self = this;
    assert.ok(self instanceof DiskCache);

    Object.defineProperties(self, {
        cacheDirP: { value: cacheDirP }
    });
}

var DCp = DiskCache.prototype;

/**
 * Primary method for setting the value of a key in the DiskCache.
 *
 * Typically, toStringP will be a zero-argument thunk that is expensive to
 * execute, and its execution will be avoided when the cache already has a
 * value for the given key.
 *
 * The fromStringP callback takes the string generated by toStringP() and
 * deserializes it.  The resulting value is cached in memory within the
 * process.
 *
 * Commoner calls setDefaultP with a toStringP function that does all the
 * necessary processing to generate a pure CommonJS module string, and
 * provides a fromStringP function that constructs a convenient Module
 * object from that string.
 */
DCp.setDefaultP = util.cachedMethod(function(key, toStringP, fromStringP) {
    return this.cacheDirP.then(function(cacheDir) {
        var file = path.join(cacheDir, key + ".js");

        return util.existsP(file).then(function(exists) {
            if (exists) {
                return util.readFileP(file);
            }

            return Q.resolve(toStringP()).then(function(string) {
                fs.writeFileSync(file, string, "utf8");
                return string;
            });
        });
    }).then(fromStringP);

}, function(key, toStringP, fromStringP) {
    return key;
});

/**
 * Method for creating a hard link between the underlying cache file and
 * some other file that should appear to contain the same contents.
 *
 * The cache directory structure is perfectly flat, with each file named
 * <key>.js according to its key.  Files that are hard-linked to files in
 * the cache directory can have arbitrary names and directory paths.
 */
DCp.linkP = function(key, file) {
    return Q.all([
        this.cacheDirP,
        util.mkdirP(path.dirname(file))
    ]).spread(function(cacheDir) {
        var cacheFile = path.join(cacheDir, key + ".js");
        return util.linkP(
            cacheFile, file
        ).catch(function(err) {
            // If the new file is not on the same device as the cache
            // file, just make a copy.
            return util.copyP(cacheFile, file);
        });
    });
};

exports.DiskCache = DiskCache;

/**
 * The ProcessCache behaves just like the DiskCache except that it makes
 * no effort to persist the result of toStringP to disk.  In other words,
 * the only benefit of the ProcessCache is that it caches the final result
 * of fromStringP within the current process (hence the name).
 */
function ProcessCache() {
    assert.ok(this instanceof ProcessCache);
}

var PCp = ProcessCache.prototype;

PCp.setDefaultP = util.cachedMethod(function(key, toStringP, fromStringP) {
    var stringP = Q.resolve(toStringP());
    return stringP.then(function(string) {
        return fromStringP(string);
    });
}, function(key, toStringP, fromStringP) {
    return key;
});

/**
 * Since there is no underlying file with which to create a hard link,
 * this method just writes a copy of the cached file contents into the
 * desired file.
 */
PCp.linkP = function(key, file) {
    return Q.all([
        util.mkdirP(path.dirname(file)),
        this.setDefaultP(
            key,
            coldCacheError, // It's a mistake to call .linkP before
            coldCacheError  // calling .setDefaultP.
        )
    ]).spread(function(dir, module) {
        return util.openExclusiveP(file).then(function(fd) {
            return util.writeFdP(fd, module.source);
        });
    });
};

function coldCacheError() {
    throw new Error("must call .setDefaultP before calling .linkP");
}

exports.ProcessCache = ProcessCache;

/**
 * ReadFileCache is an EventEmitter subclass that caches file contents in
 * memory so that subsequent calls to readFileP return the same contents,
 * regardless of any changes in the underlying file.
 *
 * Note that this class has little to do with DiskCache and ProcessCache,
 * except that all three are caches.
 */
function ReadFileCache(sourceDir) {
    assert.ok(this instanceof ReadFileCache);

    EventEmitter.call(this);

    Object.defineProperties(this, {
        sourceDir: { value: sourceDir },
        sourceCache: { value: {} }
    });
}

util.inherits(ReadFileCache, EventEmitter);
var RFCp = ReadFileCache.prototype;

/**
 * Read a file from the cache if possible, else from disk.
 */
RFCp.readFileP = function(relativePath) {
    var cache = this.sourceCache;

    relativePath = path.normalize(relativePath);

    return hasOwn.call(cache, relativePath)
        ? cache[relativePath]
        : this.noCacheReadFileP(relativePath);
};

/**
 * Read (or re-read) a file without using the cache.
 *
 * The new contents are stored in the cache for any future calls to
 * readFileP.
 */
RFCp.noCacheReadFileP = function(relativePath) {
    relativePath = path.normalize(relativePath);

    var added = !hasOwn.call(this.sourceCache, relativePath);
    var promise = this.sourceCache[relativePath] = util.readFileP(
        path.join(this.sourceDir, relativePath));

    if (added) {
        this.emit("added", relativePath);
    }

    return promise;
};

/**
 * If you have reason to believe the contents of a file have changed, call
 * this method to re-read the file and compare the new contents to the
 * cached contents.  If the new contents differ from the contents of the
 * cache, the "changed" event will be emitted.
 */
RFCp.reportPossiblyChanged = function(relativePath) {
    var self = this;
    var cached = self.readFileP(relativePath);
    var fresh = self.noCacheReadFileP(relativePath);

    Q.all([
        cached.catch(orNull),
        fresh.catch(orNull)
    ]).spread(function(oldData, newData) {
        if (oldData !== newData) {
            self.emit("changed", relativePath);
        }
    }).done();
};

/**
 * Invoke the given callback for all files currently known to the
 * ReadFileCache, and invoke it in the future when any new files become
 * known to the cache.
 */
RFCp.subscribe = function(callback, context) {
    for (var relativePath in this.sourceCache) {
        if (hasOwn.call(this.sourceCache, relativePath)) {
            callback.call(context || null, relativePath);
        }
    }

    this.on("added", function(relativePath) {
        callback.call(context || null, relativePath);
    });
};

/**
 * Avoid memory leaks by removing listeners and emptying the cache.
 */
RFCp.clear = function() {
    this.removeAllListeners();

    for (var relativePath in this.sourceCache) {
        delete this.sourceCache[relativePath];
    }
};

function orNull(err) {
    return null;
}

exports.ReadFileCache = ReadFileCache;
